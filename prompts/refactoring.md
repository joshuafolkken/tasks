# リファクタリング支援プロンプト

このプロンプトは、AI にリファクタリング提案を行う際の指示書です。小さくて簡単な方法から提案し、ユーザーが考えて対応できるよう配慮します。

## 重要な動作指示

**このプロンプトが提示された場合、以下の動作を実行してください：**

1. **リファクタリング対象の特定**
   - ユーザーが現在開いているファイルがある場合 → そのファイルを分析
   - 開いているファイルがない場合 → プロジェクト全体を分析
   - 最も改善が必要なファイルを特定

2. **除外条件の適用**
   - 以下のファイル・フォルダは分析対象から除外する：
     - `demo` フォルダ内のすべてのファイル
     - ファイル名に `demo` が含まれるファイル
     - `src/lib/server` フォルダ内のすべてのファイル
     - `src/routes/stories` フォルダ内のすべてのファイル
     - ファイル先頭に `/* @refactor-ignore */` コメントが含まれるファイル

3. **リファクタリング提案を実行**
   - 特定したファイルのリファクタリング案を3つまで提案
   - 実装可能なサンプルコードを提供
   - コメント提案は不要

4. **プロンプトの説明は行わない**
   - このプロンプトの内容説明は不要
   - 直接リファクタリング提案に移る

5. **実装時の品質保証（絶対遵守）**
   - リファクタリングを実装する場合、**必ず `read_lints` ツールでエラーを確認する**
   - エラーがある場合は **報告前に必ず修正する**
   - **Lintエラーが残っている状態での完了報告は禁止**

---

## コーディング規約の参照

- 命名規則やスタイルなどの共通ルールは `prompts/coding-standards.md` に集約されています。
- 本書では重複説明を避けるため、対象箇所では同ドキュメントを参照してください。
- 提案に含めるサンプルコードも、必ず `prompts/coding-standards.md` の規約に準拠させてください。

## 1. 基本方針

### 提案の優先順位

1. **小さくて簡単な方法から提案**
   - 1つの関数の分割
   - 1つのファイルの分割
   - 変数名の改善
   - 定数の抽出

2. **ユーザー主導の対応**
   - Agent モードでも勝手に変更しない
   - 提案のみを行い、実装はユーザーに委ねる
   - 複数の選択肢を提示

3. **関連ファイルの確認**
   - 現在指定されているファイルを中心に分析
   - 関連するファイルを特定して確認
   - 依存関係を把握

4. **コード品質の優先順位**
   - **パフォーマンスよりも、可読性・保守性を優先する**
   - 著しくパフォーマンスに問題がある場合のみ、パフォーマンス改善を検討する
   - 意図の読み取りやすさ、デバッグしやすさ、将来の変更への対応を重視する
   - 提案が特にない場合は、無理に提案しない

5. **ファイル分割の方針**
   - **メインファイルの肥大化を避けることを優先する**（詳細は `coding-standards.md` の「ファイル分割の指針」を参照）
   - 再利用可能な機能や独立した責任を持つ機能の分割を積極的に提案する
   - ファイル分割により、メインファイルの可読性と保守性が向上する場合は分割を推奨する

---

## 2. リファクタリング提案の手順

### Step 1: リファクタリング対象の分析

**重要**: 以下の優先順位で分析してください。

1. **現在開いているファイルがある場合** → そのファイルを分析（除外条件に該当する場合は除外）
2. **開いているファイルがない場合** → プロジェクト全体を分析し、最も改善が必要なファイルを特定（除外条件に該当するファイルは除外）

**除外条件**:

- `demo` フォルダ内のすべてのファイル
- ファイル名に `demo` が含まれるファイル
- `src/lib/server` フォルダ内のすべてのファイル
- `src/routes/stories` フォルダ内のすべてのファイル
- ファイル先頭に `/* @refactor-ignore */` コメントが含まれるファイル

```typescript
// 分析すべき項目
- ファイルや関数の行数・複雑度（閾値は coding-standards.md を参照）
- ネストレベルやパラメータ数（閾値は coding-standards.md を参照）
- 複数の責任を持つファイルかどうか
- 密結合な部分の特定
- プロジェクト全体の場合は、最も問題のあるファイルを特定
```

### Step 2: 関連ファイルの特定

```bash
# 関連ファイルを探す
- インポートされているファイル
- 同じディレクトリのファイル
- 類似機能のファイル
- 依存関係のあるファイル
```

### Step 3: リファクタリング候補の特定

**重要**: 一度に3つまでの具体的な提案に絞り、実装可能なサンプルコードを提供する。

**優先度の決定ルール**:

1. 高優先度の候補が3つ以上ある場合 → 高優先度のみを3つ提案
2. 高優先度が2つ以下の場合 → 高優先度 + 中優先度で3つまで
3. 高・中優先度が合計2つ以下の場合 → 高・中・低優先度で3つまで

#### 高優先度の候補

1. **メインファイルの分割**
   - **メインファイルの肥大化を避けるため、再利用可能な機能や独立した責任を持つ機能の分割**
   - メインファイルが主要な処理フローに集中できるように、詳細な実装を別ファイルに分離
   - 例: ユーザー入力処理、エラーハンドリング、ユーティリティ関数など

2. **関数の分割**
   - 行数・複雑度が `coding-standards.md` の基準を超える関数
   - 複数の責任を持つ関数

3. **ファイルの分割**
   - 300行を超えるファイル
   - 複数の責任を持つファイル
   - 関連性の低い機能が混在

4. **名前空間オブジェクトエクスポートの適用**
   - 個別の関数エクスポート（`export { func1, func2 }`）を名前空間オブジェクトエクスポートに変更
   - ファイル名と名前空間名で意図を明確にし、メソッド名を短くする工夫
   - 詳細は `coding-standards.md` の「名前空間オブジェクトエクスポート（必須）」を参照

5. **型定義の改善**
   - `any` の使用
   - 型定義の不足
   - 型の安全性向上

#### 中優先度の候補

6. **名前空間オブジェクトエクスポートの適用**
   - 個別の関数エクスポートを名前空間オブジェクトエクスポートに変更
   - ファイル名と名前空間名で意図を明確にし、メソッド名を短くする工夫
   - 詳細は `coding-standards.md` の「名前空間オブジェクトエクスポート（必須）」を参照

7. **定数の抽出**
   - `coding-standards.md` で定められたマジックナンバーや繰り返し値の定数化
   - ハードコードされた文字列の再利用整理

8. **変数名の改善**
   - `coding-standards.md` の命名規則に合致しない名前の見直し
   - 意味が不明確・長すぎる名前の再検討

#### 低優先度の候補

9. **コードの整理**
   - `coding-standards.md` で禁止されている未使用の変数・関数の削除
   - 重複コードや不要なコメントの削除

---

## 3. 提案の形式

### 提案テンプレート

```markdown
## リファクタリング提案

### 優先度: [高/中/低]

#### 現在の状況

- 問題点の説明
- 現在のコードの状況

#### 提案内容

- 具体的な改善案
- 期待される効果

#### 実装方法

- ステップバイステップの手順
- 注意点

#### サンプルコード

- そのまま利用できる具体的なコード
- 実装例を含む
- **lintエラーがないことを確認済み**

#### 関連ファイル

- 影響を受けるファイル
- 確認すべきファイル
```

### 命名規則とエクスポート規則の遵守

**重要**: 命名規則やコーディングルールの詳細は `prompts/coding-standards.md` を参照してください。提案時のサンプルコードも同ドキュメントの規約に従うこと。

**特に注意すべき点**:

- **名前空間オブジェクトエクスポート**: 複数の関数を公開する場合は、必ず名前空間オブジェクトにまとめてエクスポートする（`coding-standards.md`の「名前空間オブジェクトエクスポート（必須）」を参照）
- **アロー関数の禁止**: `function`構文で表現できる処理はアロー関数ではなく通常の`function`構文で記述する
- **メソッド名の短縮**: ファイル名と名前空間名で意図を明確にし、メソッド名を短くする工夫を行う

### 具体例

````markdown
## リファクタリング提案

### 優先度: 高

#### 現在の状況

- `process_user_data` 関数が45行で複雑度が6
- ユーザーデータの検証、変換、保存を1つの関数で処理
- テストが困難

#### 提案内容

- 関数を3つに分割：
  1. `validate_user_data` - データ検証
  2. `transform_user_data` - データ変換
  3. `save_user_data` - データ保存
- 各関数を25行以下、複雑度4以下に

#### 実装方法

1. 新しい関数を作成
2. 既存関数から処理を移動
3. 既存関数を各関数を呼び出すように変更
4. テストを追加

#### サンプルコード

```typescript
// 新しい関数を作成
const validate_user_data = (user_data: UserData): boolean => {
	if (!user_data.email || !user_data.name) {
		return false
	}
	return user_data.email.includes('@')
}

const transform_user_data = (user_data: UserData): TransformedUserData => {
	return {
		...user_data,
		email: user_data.email.toLowerCase(),
		created_at: new Date(),
	}
}

const save_user_data = async (user_data: TransformedUserData): Promise<void> => {
	await fetch('/api/users', {
		method: 'POST',
		body: JSON.stringify(user_data),
	})
}

// 既存関数を修正
const process_user_data = async (user_data: UserData): Promise<void> => {
	if (!validate_user_data(user_data)) {
		throw new Error('Invalid user data')
	}

	const transformed_data = transform_user_data(user_data)
	await save_user_data(transformed_data)
}
```

#### 関連ファイル

- `src/lib/utils/user-utils.ts` - 新規作成
- `src/lib/types/user.ts` - 型定義確認
- `src/lib/data/user-data.ts` - データ処理確認
````

---

## 4. ESLint ルールとの整合性

### リファクタリング時の注意点

**重要**: 既存コードはESLintで矯正済みですが、リファクタリング中は以下の点に注意：

1. **新しいコードの品質維持**
   - 分割した関数・ファイルがESLintルールに準拠しているか確認
   - 提案するサンプルコードがESLintルールに準拠しているか確認
   - 新規作成するファイルのコードもlintエラーがないことを確認

2. **段階的なリファクタリング対応**
   - 大きなリファクタリングでは一時的にルール違反が発生する可能性
   - 各段階でESLintルールを意識して進める
   - 各段階でlintエラーをチェックして解決する

3. **提案時の品質チェック**
   - 提案するコード例がESLintルールに準拠しているか確認
   - ユーザーが実装時に迷わないよう指針を提供
   - サンプルコードもlintエラーがないことを確認する

### 主要なESLintルール（参考）

- 具体的なルールや閾値は `prompts/coding-standards.md` に集約されています。提案・サンプルコードの作成前に必ず確認してください。

---

## 5. 提案時の注意点

### ユーザーへの配慮

1. **選択肢の提示**
   - 複数の実装方法を提示
   - メリット・デメリットを説明
   - ユーザーが判断できる情報を提供

2. **段階的な提案**
   - 小さな変更から開始
   - 大きな変更は後回し
   - 各段階で効果を確認

3. **実装の委譲**
   - 提案のみを行い、実装はユーザーに委ねる
   - コード例は参考程度に
   - ユーザーの判断を尊重

4. **命名規則の遵守**
   - サンプルコードは `prompts/coding-standards.md` の規約に従う

### 技術的な配慮

1. **既存コードの尊重**
   - 現在の設計思想を理解
   - 既存のパターンに従う
   - 破壊的変更を避ける

2. **テストの考慮**
   - 既存テストへの影響を確認
   - 新しいテストの必要性を検討
   - テストの可読性を向上

3. **パフォーマンスの考慮**
   - リファクタリングによる性能劣化を避ける
   - 不要な処理の追加を避ける
   - 既存の最適化を維持
   - **ただし、パフォーマンスよりも可読性・保守性を優先する**
   - 著しくパフォーマンスに問題がある場合のみ、パフォーマンス改善を検討する

4. **コード品質の評価基準**
   - **意図の読み取りやすさ**: コードを読んだだけで何をしているか理解できるか
   - **デバッグしやすさ**: 問題発生時に原因を特定しやすいか
   - **将来の変更への対応**: 要件変更や機能追加に対応しやすいか
   - これらの観点から、現状のコードが適切な場合は無理に提案しない

---

## 6. 提案の実行手順

### 1. リファクタリング対象の特定と分析

**重要**: 以下の手順で分析してください。

1. **現在開いているファイルがある場合** → そのファイルを分析（除外条件に該当する場合は除外）
2. **開いているファイルがない場合** → プロジェクト全体を分析し、最も改善が必要なファイルを特定（除外条件に該当するファイルは除外）

**除外条件**:

- `demo` フォルダ内のすべてのファイル
- ファイル名に `demo` が含まれるファイル
- `src/lib/server` フォルダ内のすべてのファイル
- `src/routes/stories` フォルダ内のすべてのファイル
- ファイル先頭に `/* @refactor-ignore */` コメントが含まれるファイル

```bash
# ファイルの基本情報を確認
- 行数、関数数、複雑度
- インポート、エクスポート
- 型定義、変数定義
- 複数の責任を持つファイルかどうか
- 密結合な部分の特定
- プロジェクト全体の場合は、最も問題のあるファイルを特定
```

### 2. 関連ファイルを特定

```bash
# 関連ファイルを探す
- インポートされているファイル
- 同じディレクトリのファイル
- 類似機能のファイル
```

### 3. リファクタリング候補を特定

**重要**: 一度に3つまでの具体的な提案に絞り、実装可能なサンプルコードを提供する。

**優先度の決定ルール**:

1. 高優先度の候補が3つ以上ある場合 → 高優先度のみを3つ提案
2. 高優先度が2つ以下の場合 → 高優先度 + 中優先度で3つまで
3. 高・中優先度が合計2つ以下の場合 → 高・中・低優先度で3つまで

```typescript
// 優先度順に候補をリストアップ（最大3つ）
// 例1: 高優先度が3つ以上ある場合
1. 高優先度: 関数分割
2. 高優先度: ファイル分割
3. 高優先度: 型定義改善

// 例2: 高優先度が2つ以下の場合
1. 高優先度: 関数分割
2. 高優先度: ファイル分割
3. 中優先度: 定数抽出
```

### 4. 提案を作成

**重要**: 提案を作成する際は、以下の点を確認してください。

1. **サンプルコードのlintチェック**
   - 提案するサンプルコードがlintエラーがないことを確認
   - 新規作成するファイルのコードもlintエラーがないことを確認

2. **提案テンプレート**

```markdown
## リファクタリング提案

### 優先度: [高/中/低]

#### 現在の状況

- 問題点の説明
- 現在のコードの状況

#### 提案内容

- 具体的な改善案
- 期待される効果

#### 実装方法

- ステップバイステップの手順
- 注意点

#### サンプルコード

- そのまま利用できる具体的なコード
- 実装例を含む
- **lintエラーがないことを確認済み**

#### 関連ファイル

- 影響を受けるファイル
- 確認すべきファイル
```

### 5. ユーザーに提案

- 提案内容を説明
- 実装方法を提示
- サンプルコードを提供
- ユーザーの判断を待つ
- 必要に応じて追加情報を提供

---

## 7. よくあるリファクタリングパターン

### 関数分割のパターン

```typescript
// Before: 長い関数
const process_user_data = (user_data: UserData): ProcessedUserData => {
	// 検証処理 (10行)
	// 変換処理 (15行)
	// 保存処理 (10行)
	// 通知処理 (5行)
}

// After: 分割された関数
const validate_user_data = (user_data: UserData): boolean => {
	// 検証処理
}

const transform_user_data = (user_data: UserData): TransformedUserData => {
	// 変換処理
}

const save_user_data = (user_data: TransformedUserData): void => {
	// 保存処理
}

const notify_user = (user_data: ProcessedUserData): void => {
	// 通知処理
}

const process_user_data = (user_data: UserData): ProcessedUserData => {
	if (!validate_user_data(user_data)) {
		throw new Error('Invalid user data')
	}

	const transformed_data = transform_user_data(user_data)
	save_user_data(transformed_data)
	notify_user(transformed_data)

	return transformed_data
}
```

### ファイル分割のパターン

```typescript
// Before: 大きなファイル (400行)
// user-service.ts
export class UserService {
	// 認証関連 (100行)
	// データ処理関連 (150行)
	// 通知関連 (100行)
	// ユーティリティ関連 (50行)
}

// After: 分割されたファイル
// user-auth.ts
export class UserAuth {
	// 認証関連
}

// user-data.ts
export class UserData {
	// データ処理関連
}

// user-notification.ts
export class UserNotification {
	// 通知関連
}

// user-utils.ts
export class UserUtils {
	// ユーティリティ関連
}
```

### 定数抽出のパターン

```typescript
// Before: マジックナンバー
const process_items = (items: Item[]): ProcessedItem[] => {
	return items
		.filter((item) => item.status === 1)
		.map((item) => ({ ...item, priority: 2 }))
		.sort((a, b) => b.score - a.score)
		.slice(0, 10)
}

// After: 定数抽出
const ACTIVE_STATUS = 1
const HIGH_PRIORITY = 2
const MAX_RESULTS = 10

const process_items = (items: Item[]): ProcessedItem[] => {
	return items
		.filter((item) => item.status === ACTIVE_STATUS)
		.map((item) => ({ ...item, priority: HIGH_PRIORITY }))
		.sort((a, b) => b.score - a.score)
		.slice(0, MAX_RESULTS)
}
```

### 名前空間オブジェクトエクスポートのパターン

```typescript
// Before: 個別の関数エクスポート
// ファイル名: commands.ts
async function exec_git_branch(): Promise<string> {
	return await exec_git_command('rev-parse --abbrev-ref HEAD')
}

async function exec_git_status(): Promise<string> {
	return await exec_git_command('status --porcelain')
}

export { exec_git_branch, exec_git_status }
```

```typescript
// After: 名前空間オブジェクトエクスポート
// ファイル名: git-command.ts
// 名前空間名: git_command

async function branch(): Promise<string> {
	return await exec_git_command('rev-parse --abbrev-ref HEAD')
}

async function status(): Promise<string> {
	return await exec_git_command('status --porcelain')
}

const git_command = {
	branch,
	status,
}

export { git_command }
```

**使用例**:

```typescript
// インポート
import { git_command } from './git/git-command.js'

// 使用（メソッド名が短く、名前空間で意図が明確）
const branch_name = await git_command.branch()
const status_output = await git_command.status()
```

**ポイント**:

- ファイル名と名前空間名で意図を明確にする（`git-command.ts` → `git_command`）
- メソッド名は短く、名前空間で補完する（`exec_git_branch()` → `git_command.branch()`）
- アロー関数は使わず、通常の`function`構文を使用する

---

## 8. チェックリスト

提案前に以下を確認：

- [ ] **提案するサンプルコードにlintエラーがないことを確認した**
- [ ] **新規作成するファイルのコードにlintエラーがないことを確認した**
- [ ] **複数の関数を公開する場合は名前空間オブジェクトエクスポートを使用しているか確認した**（`coding-standards.md`の「名前空間オブジェクトエクスポート（必須）」を参照）
- [ ] **アロー関数ではなく通常の`function`構文を使用しているか確認した**
- [ ] 現在のファイルの状況を正確に把握した
- [ ] 関連ファイルを確認した
- [ ] ESLint ルールに準拠している
- [ ] 一度に3つまでの提案に絞っている
- [ ] 実装可能なサンプルコードを提供している
- [ ] 実装はユーザーに委ねている
- [ ] 既存の設計思想を尊重している
- [ ] テストへの影響を考慮している
- [ ] パフォーマンスへの影響を考慮している

---

## 9. 参考ファイル

- `prompts/coding-standards.md` - ESLint ルールの詳細
- `eslint.config.js` - 設定ファイル
- `src/lib/` - 既存の実装パターン
- `src/routes/` - ページコンポーネントの実装

---

**重要**: このプロンプトが提示された場合、以下の手順でリファクタリング提案を実行してください：

1. **リファクタリング対象の特定**
   - 現在開いているファイルがある場合 → そのファイルを分析（除外条件に該当する場合は除外）
   - 開いているファイルがない場合 → プロジェクト全体を分析し、最も改善が必要なファイルを特定（除外条件に該当するファイルは除外）

2. **除外条件の適用**
   - `demo` フォルダ内のすべてのファイル
   - ファイル名に `demo` が含まれるファイル
   - `src/lib/server` フォルダ内のすべてのファイル
   - `src/routes/stories` フォルダ内のすべてのファイル
   - ファイル先頭に `/* @refactor-ignore */` コメントが含まれるファイル

3. **提案の実行**
   - 特定したファイルのリファクタリング案を3つまで提案
   - 実装可能なサンプルコードを提供
   - **提案するサンプルコードにlintエラーがないことを確認**
   - **新規作成するファイルのコードにlintエラーがないことを確認**
   - コメント提案は不要
   - 提案のみを行い、実装はユーザーに委ねる
   - 一度に3つまでの具体的な提案に絞る
   - 高優先度の候補が3つ以上ある場合は高優先度のみを提案

---

## 10. リファクタリング実装後の報告手順

**重要**: ユーザーが「対応して」などと指示してリファクタリングを実装した場合、**例外なく以下の手順を実行してください**：

1. **実装後のlintエラーチェック（絶対必須）**
   - リファクタリング実装直後に、**必ず `read_lints` ツールを実行する**
   - `read_lints({ paths: ['変更したファイル1', '変更したファイル2', '新規作成したファイル1'] })` のように、**すべての関与したファイルを指定して確認する**
   - この手順を省略することは禁止されています

2. **lintエラーの即時修正（修正ループ）**
   - lintエラーが1つでも見つかった場合、**ユーザーに報告する前に修正を行う**
   - 修正後、再度 `read_lints` を実行し、エラーが0件になるまで繰り返す
   - **Lintエラーが残っている状態での完了報告は禁止**

3. **報告内容**
   - 実施した変更内容を説明
   - **「Lintエラーチェックを実施し、エラーがないことを確認しました」** と明記する
   - もし自動修正できないエラーが残った場合のみ、その理由と共に報告する
